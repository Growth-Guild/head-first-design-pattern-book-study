# Chapter 1. 디자인 패턴 소개와 전략 패턴

### 무분별한 상속의 문제점
* 요구사항이 변경되어 상위 클래스에서 수정이 발생할 경우, 그 영향 범위가 하위 클래스에 미친다.
* 하위 클래스에서 원치 않는 동작이 상속될 경우, 오버라이드를 통해서 불필요한 재정의가 필요해진다.

### 각자의 행동에 맞게 인터페이스를 정의하는 방법은 어떠한가?
 모든 서브클래스에서 특정 기능이 필요한건 아니므로 특정 기능을 위한 인터페이스를 정의하고 구체 클래스에서 이를 구현하면 될 것 같지만 재사용이 불가능하다는 문제점도 있다.
 
- - -

### 디자인 원칙
> 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.

* 바뀌는 부분은 따로 분리하여 캡슐화하여 추후에 바뀌지 않는 부분에 영향을 미치지 않고 수정하거나 확장할 수 있도록 해야한다. (SRP, OCP 원칙)

- - -

## 변화하는 부분과 그렇지 않은 부분 분리하기
* 변화하는 부분과 변화하지 않는 부분을 분리하려면 새로운 집합을 정의하여 분리한다.
* 각 클래스 집합에는 각각의 행동을 구현한다.

### 오리 예제
요구 사항
* 오리는 날 수 있다.
* 오리는 꽥꽥 거릴 수 있다.

<br>

* 위 요구 사항에서 오리는 종류에 따라 하늘을 나는 행위, 꽥꽥 거리는 행위가 달라진다.
* Duck의 인스턴스에 행동을 할당하여 유연성을 만들 수 있다.

### 디자인 원칙
> 구현보다는 인터페이스에 맞춰서 프로그래밍한다.

* 상위 형식의 인스턴스를 만드는 과정을 직접 코드로 정의하는 대신 구체적으로 구현된 객체를 실행 시에 주입(DI)해주는 것이 좋다. (생성과 실행의 분리)

### 오리의 행동을 구현하는 방법
![fly-behavior.png](../../java/chapter_1/asset/fly-behavior.png)
* 위와 같이 행동을 인터페이스화 시키고 그 구체적인 방법에 대해서는 구체 클래스에서 정의하면 다형성을 통해 재사용이 가능해진다.
* 특정한 구체 클래스에 종속되지 않는다.

```java
public abstract class Duck {
    protected FlyBehavior flyBehavior;

    public void performQuack() {
        flyBehavior.fly();
    }

    protected abstract void display();
}
```
```java
public class MallardDuck extends Duck {
    public MallardDuck(FlyBehavior flyBehavior) {
        this.flyBehavior = flyBehavior;
    }

    @Override
    protected void display() {
        System.out.println("저는 물오리 입니다.");
    }
}
```
* 구현하고자 하는 오리의 행동마다 의존성을 주입해줌으로써, 오리 클래스는 어떻게 날 수 있는지에 대한 구체적인 방법은 알지 못한다.
* 어떻게 날지는 FlyBehavior가 결정한다. Duck은 하늘을 나는 명령을 FlyBehavior에 전달하여 위임한다.
* 세터 주입을 통해서 행동 전략을 유연하게 교체할 수 있다.
* 하늘을 나는 새로운 행동 전략이 필요하면 FlyBehavior 인터페이스를 구현한 새로운 구체 클래스를 추가하면 된다. 하늘을 나는 요구사항의 변경 사항이 기존 클래스들에 영향을 미치지 않게 된다.

### 디자인 원칙
> 상속보다는 컴포지션을 활용한다.
